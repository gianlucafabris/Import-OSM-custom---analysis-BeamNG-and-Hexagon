---
title: "Hexagon analysis"
author: "Gianluca Fabris"
output: pdf_document
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=FALSE, message = FALSE, warning = FALSE)
```

```{r}
library(dplyr)
library(moments)
library(reticulate)
library(ggplot2)
library(grid)
library(gridExtra)

raw = read.csv("data/importosm_raw.csv", header = TRUE, sep = ",")
raw2 = read.csv("data/importosm_raw2.csv", header = TRUE, sep = ",")
raw3 = read.csv("data/importosm_raw3.csv", header = TRUE, sep = ",")
custom = read.csv("data/importosm_custom.csv", header = TRUE, sep = ",")
custom2 = read.csv("data/importosm_custom2.csv", header = TRUE, sep = ",")
custom3 = read.csv("data/importosm_custom3.csv", header = TRUE, sep = ",")
custom_elevation = read.csv("data/importosm_custom_elevation.csv", header = TRUE, sep = ",")
custom_elevation2 = read.csv("data/importosm_custom_elevation2.csv", header = TRUE, sep = ",")
custom_elevation3 = read.csv("data/importosm_custom_elevation3.csv", header = TRUE, sep = ",")

# rename columns, merge data and align data
names(raw) = c("time", "frame", "id", "category", "type", "vismask", "name", "geometry_dim_x", "geometry_dim_y", "geometry_dim_z", "geometry_offset_x", "geometry_offset_y", "geometry_offset_z", "position_x", "position_y", "position_z", "position_h", "position_p", "position_r", "position_flags", "position_type", "position_system", "speed_x", "speed_y", "speed_z", "speed_h", "speed_p", "speed_r", "speed_flags", "speed_type", "speed_system", "acceleration_x", "acceleration_y", "acceleration_z", "acceleration_h", "acceleration_p", "acceleration_r", "acceleration_flags", "acceleration_type", "acceleration_system", "distance - m", "null")
names(raw2) = c("time", "frame", "id", "lightmask", "steering", "steering_wheeltorque", "acc_mask", "acc_speed", "battery_state", "battery_rate", "displaylightmask", "fuelgauge", "null")
names(raw3) = c("time", "frame", "id", "road_id", "lane_id", "flags", "road_s", "road_t", "lane_offset", "rel_h", "rel_p", "rel_r", "road_type", "path_s", "null")
names(custom) = c("time", "frame", "id", "category", "type", "vismask", "name", "geometry_dim_x", "geometry_dim_y", "geometry_dim_z", "geometry_offset_x", "geometry_offset_y", "geometry_offset_z", "position_x", "position_y", "position_z", "position_h", "position_p", "position_r", "position_flags", "position_type", "position_system", "speed_x", "speed_y", "speed_z", "speed_h", "speed_p", "speed_r", "speed_flags", "speed_type", "speed_system", "acceleration_x", "acceleration_y", "acceleration_z", "acceleration_h", "acceleration_p", "acceleration_r", "acceleration_flags", "acceleration_type", "acceleration_system", "distance - m", "null")
names(custom2) = c("time", "frame", "id", "lightmask", "steering", "steering_wheeltorque", "acc_mask", "acc_speed", "battery_state", "battery_rate", "displaylightmask", "fuelgauge", "null")
names(custom3) = c("time", "frame", "id", "road_id", "lane_id", "flags", "road_s", "road_t", "lane_offset", "rel_h", "rel_p", "rel_r", "road_type", "path_s", "null")
names(custom_elevation) = c("time", "frame", "id", "category", "type", "vismask", "name", "geometry_dim_x", "geometry_dim_y", "geometry_dim_z", "geometry_offset_x", "geometry_offset_y", "geometry_offset_z", "position_x", "position_y", "position_z", "position_h", "position_p", "position_r", "position_flags", "position_type", "position_system", "speed_x", "speed_y", "speed_z", "speed_h", "speed_p", "speed_r", "speed_flags", "speed_type", "speed_system", "acceleration_x", "acceleration_y", "acceleration_z", "acceleration_h", "acceleration_p", "acceleration_r", "acceleration_flags", "acceleration_type", "acceleration_system", "distance - m", "null")
names(custom_elevation2) = c("time", "frame", "id", "lightmask", "steering", "steering_wheeltorque", "acc_mask", "acc_speed", "battery_state", "battery_rate", "displaylightmask", "fuelgauge", "null")
names(custom_elevation3) = c("time", "frame", "id", "road_id", "lane_id", "flags", "road_s", "road_t", "lane_offset", "rel_h", "rel_p", "rel_r", "road_type", "path_s", "null")

raw = raw[, !(names(raw) %in% c("frame", "id", "category", "type", "vismask", "name", "geometry_dim_x", "geometry_dim_y", "geometry_dim_z", "geometry_offset_x", "geometry_offset_y", "geometry_offset_z", "position_flags", "position_type", "position_system", "speed_flags", "speed_type", "speed_system", "acceleration_flags", "acceleration_type", "acceleration_system", "distance - m", "null"))]
raw2 = raw2[, !(names(raw2) %in% c("frame", "id", "lightmask", "steering_wheeltorque", "acc_mask", "acc_speed", "battery_state", "battery_rate", "displaylightmask", "fuelgauge", "null"))]
raw3 = raw3[, !(names(raw3) %in% c("frame", "id", "lane_id", "flags", "road_s", "rel_h", "rel_p", "rel_r", "road_type", "path_s", "null"))]
custom = custom[, !(names(custom) %in% c("frame", "id", "category", "type", "vismask", "name", "geometry_dim_x", "geometry_dim_y", "geometry_dim_z", "geometry_offset_x", "geometry_offset_y", "geometry_offset_z", "position_flags", "position_type", "position_system", "speed_flags", "speed_type", "speed_system", "acceleration_flags", "acceleration_type", "acceleration_system", "distance - m", "null"))]
custom2 = custom2[, !(names(custom2) %in% c("frame", "id", "lightmask", "steering_wheeltorque", "acc_mask", "acc_speed", "battery_state", "battery_rate", "displaylightmask", "fuelgauge", "null"))]
custom3 = custom3[, !(names(custom3) %in% c("frame", "id", "lane_id", "flags", "road_s", "rel_h", "rel_p", "rel_r", "road_type", "path_s", "null"))]
custom_elevation = custom_elevation[, !(names(custom_elevation) %in% c("frame", "id", "category", "type", "vismask", "name", "geometry_dim_x", "geometry_dim_y", "geometry_dim_z", "geometry_offset_x", "geometry_offset_y", "geometry_offset_z", "position_flags", "position_type", "position_system", "speed_flags", "speed_type", "speed_system", "acceleration_flags", "acceleration_type", "acceleration_system", "distance - m", "null"))]
custom_elevation2 = custom_elevation2[, !(names(custom_elevation2) %in% c("frame", "id", "lightmask", "steering_wheeltorque", "acc_mask", "acc_speed", "battery_state", "battery_rate", "displaylightmask", "fuelgauge", "null"))]
custom_elevation3 = custom_elevation3[, !(names(custom_elevation3) %in% c("frame", "id", "lane_id", "flags", "road_s", "rel_h", "rel_p", "rel_r", "road_type", "path_s", "null"))]

raw = merge(merge(raw, raw2, by = "time", all = FALSE), raw3, by = "time", all = FALSE)
rm(raw2)
rm(raw3)
custom = merge(merge(custom, custom2, by = "time", all = FALSE), custom3, by = "time", all = FALSE)
rm(custom2)
rm(custom3)
custom_elevation = merge(merge(custom_elevation, custom_elevation2, by = "time", all = FALSE), custom_elevation3, by = "time", all = FALSE)
rm(custom_elevation2)
rm(custom_elevation3)

# adding missing data and data normalization
raw = raw %>% mutate(
  dist_planar = cumsum(c(0, sapply(2:nrow(raw), function(i){
    sqrt((position_x[i] - position_x[i-1])^2 + (position_y[i] - position_y[i-1])^2)
  }))),
  dist_spatial = cumsum(c(0, sapply(2:nrow(raw), function(i){
    sqrt((position_x[i] - position_x[i-1])^2 + (position_y[i] - position_y[i-1])^2 + (position_z[i] - position_z[i-1])^2)
  })))
)
custom = custom %>% mutate(
  dist_planar = cumsum(c(0, sapply(2:nrow(custom), function(i){
    sqrt((position_x[i] - position_x[i-1])^2 + (position_y[i] - position_y[i-1])^2)
  }))),
  dist_spatial = cumsum(c(0, sapply(2:nrow(custom), function(i){
    sqrt((position_x[i] - position_x[i-1])^2 + (position_y[i] - position_y[i-1])^2 + (position_z[i] - position_z[i-1])^2)
  })))
)
custom_elevation = custom_elevation %>% mutate(
  dist_planar = cumsum(c(0, sapply(2:nrow(custom_elevation), function(i){
    sqrt((position_x[i] - position_x[i-1])^2 + (position_y[i] - position_y[i-1])^2)
  }))),
  dist_spatial = cumsum(c(0, sapply(2:nrow(custom_elevation), function(i){
    sqrt((position_x[i] - position_x[i-1])^2 + (position_y[i] - position_y[i-1])^2 + (position_z[i] - position_z[i-1])^2)
  })))
)

raw$dist_planar = raw$dist_planar - min(unlist(raw$dist_planar))
raw$dist_spatial = raw$dist_spatial - min(unlist(raw$dist_spatial))
custom$dist_planar = custom$dist_planar - min(unlist(custom$dist_planar))
custom$dist_spatial = custom$dist_spatial - min(unlist(custom$dist_spatial))
custom_elevation$dist_planar = custom_elevation$dist_planar - min(unlist(custom_elevation$dist_planar))
custom_elevation$dist_spatial = custom_elevation$dist_spatial - min(unlist(custom_elevation$dist_spatial))

raw = raw %>% mutate(
  speed_planar = sqrt((speed_x)^2 + (speed_y)^2),
  speed_spatial = sqrt((speed_x)^2 + (speed_y)^2 + (speed_z)^2)
)
custom = custom %>% mutate(
  speed_planar = sqrt((speed_x)^2 + (speed_y)^2),
  speed_spatial = sqrt((speed_x)^2 + (speed_y)^2 + (speed_z)^2)
)
custom_elevation = custom_elevation %>% mutate(
  speed_planar = sqrt((speed_x)^2 + (speed_y)^2),
  speed_spatial = sqrt((speed_x)^2 + (speed_y)^2 + (speed_z)^2)
)

raw = raw %>% mutate(
  acceleration_planar = sqrt((acceleration_x)^2 + (acceleration_y)^2),
  acceleration_spatial = sqrt((acceleration_x)^2 + (acceleration_y)^2 + (acceleration_z)^2)
)
custom = custom %>% mutate(
  acceleration_planar = sqrt((acceleration_x)^2 + (acceleration_y)^2),
  acceleration_spatial = sqrt((acceleration_x)^2 + (acceleration_y)^2 + (acceleration_z)^2)
)
custom_elevation = custom_elevation %>% mutate(
  acceleration_planar = sqrt((acceleration_x)^2 + (acceleration_y)^2),
  acceleration_spatial = sqrt((acceleration_x)^2 + (acceleration_y)^2 + (acceleration_z)^2)
)

raw = raw %>% mutate(
  elevation_cum = c(NA, cumsum(abs(diff(position_z))))
)
custom = custom %>% mutate(
  elevation_cum = c(NA, cumsum(abs(diff(position_z))))
)
custom_elevation = custom_elevation %>% mutate(
  elevation_cum = c(NA, cumsum(abs(diff(position_z))))
)

raw = raw %>% filter(time >= 1)
raw = raw %>% filter(dist_planar < 800 | (dist_planar >= 800 & sqrt((speed_x)^2 + (speed_y)^2 + (speed_z)^2) > 0.5))
custom = custom %>% filter(time >= 1)
custom = custom %>% filter(dist_planar < 800 | (dist_planar >= 800 & sqrt((speed_x)^2 + (speed_y)^2 + (speed_z)^2) > 0.5))
custom_elevation = custom_elevation %>% filter(time >= 1)
custom_elevation = custom_elevation %>% filter(dist_planar < 800 | (dist_planar >= 800 & sqrt((speed_x)^2 + (speed_y)^2 + (speed_z)^2) > 0.5))

# position rad -> deg
raw = raw %>% mutate(
  position_h_norm = (position_h * 180 / pi) %% 360 - 180,
  position_p_norm = (position_p * 180 / pi + 180) %% 360 - 180,
  position_r_norm = (position_r * 180 / pi + 180) %% 360 - 180
)
custom = custom %>% mutate(
  position_h_norm = (position_h * 180 / pi) %% 360 - 180,
  position_p_norm = (position_p * 180 / pi + 180) %% 360 - 180,
  position_r_norm = (position_r * 180 / pi + 180) %% 360 - 180
)
custom_elevation = custom_elevation %>% mutate(
  position_h_norm = (position_h * 180 / pi) %% 360 - 180,
  position_p_norm = (position_p * 180 / pi + 180) %% 360 - 180,
  position_r_norm = (position_r * 180 / pi + 180) %% 360 - 180
)

# speed m/s -> km/h
raw = raw %>% mutate(
  speed_x_norm = speed_x * 3.6,
  speed_y_norm = speed_y * 3.6,
  speed_z_norm = speed_z * 3.6,
  speed_planar_norm = speed_planar * 3.6,
  speed_spatial_norm = speed_spatial * 3.6
)
custom = custom %>% mutate(
  speed_x_norm = speed_x * 3.6,
  speed_y_norm = speed_y * 3.6,
  speed_z_norm = speed_z * 3.6,
  speed_planar_norm = speed_planar * 3.6,
  speed_spatial_norm = speed_spatial * 3.6
)
custom_elevation = custom_elevation %>% mutate(
  speed_x_norm = speed_x * 3.6,
  speed_y_norm = speed_y * 3.6,
  speed_z_norm = speed_z * 3.6,
  speed_planar_norm = speed_planar * 3.6,
  speed_spatial_norm = speed_spatial * 3.6
)

# acceleration m/s^2 -> G
raw = raw %>% mutate(
  acceleration_x_norm = acceleration_x / 9.81,
  acceleration_y_norm = acceleration_y / 9.81,
  acceleration_z_norm = acceleration_z / 9.81,
  acceleration_planar_norm = acceleration_planar / 9.81,
  acceleration_spatial_norm = acceleration_spatial / 9.81
)
custom = custom %>% mutate(
  acceleration_x_norm = acceleration_x / 9.81,
  acceleration_y_norm = acceleration_y / 9.81,
  acceleration_z_norm = acceleration_z / 9.81,
  acceleration_planar_norm = acceleration_planar / 9.81,
  acceleration_spatial_norm = acceleration_spatial / 9.81
)
custom_elevation = custom_elevation %>% mutate(
  acceleration_x_norm = acceleration_x / 9.81,
  acceleration_y_norm = acceleration_y / 9.81,
  acceleration_z_norm = acceleration_z / 9.81,
  acceleration_planar_norm = acceleration_planar / 9.81,
  acceleration_spatial_norm = acceleration_spatial / 9.81
)

#adding distance from reference line (exact) and importing road (for visualization) (approximated)
raw = raw %>% mutate(
  dist_reference = road_t
)
custom = custom %>% mutate(
  dist_reference = road_t
)
custom_elevation = custom_elevation %>% mutate(
  dist_reference = road_t
)

raw = raw[, !(names(raw) %in% c("road_t", "lane_offset"))]
custom = custom[, !(names(custom) %in% c("road_t", "lane_offset"))]
custom_elevation = custom_elevation[, !(names(custom_elevation) %in% c("road_t", "lane_offset"))]

theta = atan2(diff(raw$position_y), diff(raw$position_x))
theta = c(theta, tail(theta, n=1))
road_raw <- data.frame(x = raw$position_x - raw$dist_reference * sin(theta), y = raw$position_y + raw$dist_reference * cos(theta))
theta = atan2(diff(custom$position_y), diff(custom$position_x))
theta = c(theta, tail(theta, n=1))
road_custom <- data.frame(x = custom$position_x - custom$dist_reference * sin(theta), y = custom$position_y + custom$dist_reference * cos(theta))
theta = atan2(diff(custom_elevation$position_y), diff(custom_elevation$position_x))
theta = c(theta, tail(theta, n=1))
road_custom_elevation <- data.frame(x = custom_elevation$position_x - custom_elevation$dist_reference * sin(theta), y = custom_elevation$position_y + custom_elevation$dist_reference * cos(theta))
rm(theta)

lane_width_raw = 3.5
lane_width_custom = 3.75
lane_width_custom_elevation = 3.75

if(!file.exists("output")){
  dir.create("output")
}

```

# Stats, graphs and test comparisons

```{r}
plot_3var = function(data, title, variable1, variable1_scale, variable1_name, variable2, variable2_scale, variable2_name, variable3, variable3_scale, variable3_name){
  p = data %>%
    ggplot(aes(x = variable1, y = variable2, color = variable3)) +
      scale_x_continuous(limits = c(variable1_scale[1], variable1_scale[2]), breaks = seq(variable1_scale[1], variable1_scale[2], variable1_scale[3])) +
      scale_y_continuous(limits = c(variable2_scale[1], variable2_scale[2]), breaks = seq(variable2_scale[1], variable2_scale[2], variable2_scale[3])) +
      coord_fixed(ratio = 1) +
      scale_color_gradient(low = "#6B9EE1", high = "#86F5FA", limits = c(variable3_scale[1], variable3_scale[2]), breaks = seq(variable3_scale[1], variable3_scale[2], variable3_scale[3])) +
      labs(title = title, x = variable1_name, y = variable2_name, colour = variable3_name) +
      theme_minimal() +
      theme(axis.text.x = element_text(color = "#000000"), axis.text.y = element_text(color = "#000000"), axis.line = element_line(color = "#000000"), panel.background = element_rect(fill = "#ffffff"), panel.grid.major.x = element_line(colour = "#ebebeb"), panel.grid.major.y = element_line(colour = "#ebebeb"), plot.title = element_text(size = rel(1.5)))
  return(p)
}

plot_2var = function(data, title, variable1, variable1_scale, variable1_name, variable2, variable2_scale, variable2_name){
  p = data %>%
    ggplot(aes(x = variable1, y = variable2)) +
      scale_x_continuous(limits = c(variable1_scale[1], variable1_scale[2]), breaks = seq(variable1_scale[1], variable1_scale[2], variable1_scale[3])) +
      scale_y_continuous(limits = c(variable2_scale[1], variable2_scale[2]), breaks = seq(variable2_scale[1], variable2_scale[2], variable2_scale[3])) +
      labs(title = title, x = variable1_name, y = variable2_name) +
      theme_minimal() +
      theme(axis.text.x = element_text(color = "#000000"), axis.text.y = element_text(color = "#000000"), axis.line = element_line(color = "#000000"), panel.background = element_rect(fill = "#ffffff"), panel.grid.major.x = element_line(colour = "#ebebeb"), panel.grid.major.y = element_line(colour = "#ebebeb"), plot.title = element_text(size = rel(1.5)))
  return(p)
}

calc_scale = function(var){
  return(c(floor(min(var)), floor(max(var))+1, (floor(max(var))+1 - floor(min(var)))/4))
}

#stats
#time
raw[nrow(raw),]$time
custom[nrow(custom),]$time
custom_elevation[nrow(custom_elevation),]$time

#distance planar
raw[nrow(raw),]$dist_planar
custom[nrow(custom),]$dist_planar
custom_elevation[nrow(custom_elevation),]$dist_planar

#distance spatial
raw[nrow(raw),]$dist_spatial
custom[nrow(custom),]$dist_spatial
custom_elevation[nrow(custom_elevation),]$dist_spatial

#elevation
raw[nrow(raw),]$elevation_cum
custom[nrow(custom),]$elevation_cum
custom_elevation[nrow(custom_elevation),]$elevation_cum

#graphs
#position z
ggsave("output/position z.png", grid.arrange(
  plot_3var(
    raw, "A) Raw - position x y and z",
    raw$position_x-min(raw$position_x), c(0, floor(max(raw$position_x-min(raw$position_x)))+1, 100), "position x - m",
    raw$position_y-min(raw$position_y), c(0, floor(max(raw$position_y-min(raw$position_y)))+1, 100), "position y - m",
    raw$position_z-min(raw$position_z), c(0, floor(max(raw$position_z-min(raw$position_z)))+1, 1), "position z - m"
  ) +
    geom_point(alpha = 1),
  plot_3var(
    custom, "B) Custom - position x y and z",
    custom$position_x-min(custom$position_x), c(0, floor(max(custom$position_x-min(custom$position_x)))+1, 100), "position x - m",
    custom$position_y-min(custom$position_y), c(0, floor(max(custom$position_y-min(custom$position_y)))+1, 100), "position y - m",
    custom$position_z-min(custom$position_z), c(0, floor(max(custom$position_z-min(custom$position_z)))+1, 1), "position z - m"
  ) +
    geom_point(alpha = 1),
  plot_3var(
    custom_elevation, "C) Custom elevation - position x y and z",
    custom_elevation$position_x-min(custom_elevation$position_x), c(0, floor(max(custom_elevation$position_x-min(custom_elevation$position_x)))+1, 100), "position x - m",
    custom_elevation$position_y-min(custom_elevation$position_y), c(0, floor(max(custom_elevation$position_y-min(custom_elevation$position_y)))+1, 100), "position y - m",
    custom_elevation$position_z-min(custom_elevation$position_z), c(0, floor(max(custom_elevation$position_z-min(custom_elevation$position_z)))+1, 1), "position z - m"
  ) +
    geom_point(alpha = 1),
  plot_2var(
    raw, "D) Raw - z",
    raw$time-min(raw$time), c(0, floor(max(raw$time-min(raw$time)))+1, 10), "time - s",
    raw$position_z-min(raw$position_z), c(0, floor(max(raw$position_z-min(raw$position_z)))+1, 1), "position z - m"
  ) +
    geom_line(color="#6B9EE1"),
  plot_2var(
    custom, "E) Custom - z",
    custom$time-min(custom$time), c(0, floor(max(custom$time-min(custom$time)))+1, 10), "time - s",
    custom$position_z-min(custom$position_z), c(0, floor(max(custom$position_z-min(custom$position_z)))+1, 1), "position z - m"
  ) +
    geom_line(color="#6B9EE1"),
  plot_2var(
    custom_elevation, "F) Custom elevation - z",
    custom_elevation$time-min(custom_elevation$time), c(0, floor(max(custom_elevation$time-min(custom_elevation$time)))+1, 10), "time - s",
    custom_elevation$position_z-min(custom_elevation$position_z), c(0, floor(max(custom_elevation$position_z-min(custom_elevation$position_z)))+1, 1), "position z - m"
  ) +
    geom_line(color="#6B9EE1"),
  nrow = 2, ncol = 3), width = 10*3, height = 5*2)

#position rph
ggsave("output/position rph.png", grid.arrange(
  # plot_3var(
  #   raw, "X) Raw - position x y and pitch",
  #   raw$position_x-min(raw$position_x), c(0, floor(max(raw$position_x-min(raw$position_x)))+1, 100), "position x - m",
  #   raw$position_y-min(raw$position_y), c(0, floor(max(raw$position_y-min(raw$position_y)))+1, 100), "position y - m",
  #   raw$position_p_norm, calc_scale(c(raw$position_p_norm, custom$position_p_norm, custom_elevation$position_p_norm)), "pitch - deg"
  # ) +
  #   geom_point(alpha = 1),
  # plot_3var(
  #   custom, "Y) Custom - position x y and pitch",
  #   custom$position_x-min(custom$position_x), c(0, floor(max(custom$position_x-min(custom$position_x)))+1, 100), "position x - m",
  #   custom$position_y-min(custom$position_y), c(0, floor(max(custom$position_y-min(custom$position_y)))+1, 100), "position y - m",
  #   custom$position_p_norm, calc_scale(c(raw$position_p_norm, custom$position_p_norm, custom_elevation$position_p_norm)), "pitch - deg"
  # ) +
  #   geom_point(alpha = 1),
  # plot_3var(
  #   custom_elevation, "Z) Custom elevation - position x y and pitch",
  #   custom_elevation$position_x-min(custom_elevation$position_x), c(0, floor(max(custom_elevation$position_x-min(custom_elevation$position_x)))+1, 100), "position x - m",
  #   custom_elevation$position_y-min(custom_elevation$position_y), c(0, floor(max(custom_elevation$position_y-min(custom_elevation$position_y)))+1, 100), "position y - m",
  #   custom_elevation$position_p_norm, calc_scale(c(raw$position_p_norm, custom$position_p_norm, custom_elevation$position_p_norm)), "pitch - deg"
  # ) +
  #   geom_point(alpha = 1),
  # plot_3var(
  #   raw, "X) Raw - position x y and roll",
  #   raw$position_x-min(raw$position_x), c(0, floor(max(raw$position_x-min(raw$position_x)))+1, 100), "position x - m",
  #   raw$position_y-min(raw$position_y), c(0, floor(max(raw$position_y-min(raw$position_y)))+1, 100), "position y - m",
  #   raw$position_r_norm, calc_scale(c(raw$position_r_norm, custom$position_r_norm, custom_elevation$position_r_norm)), "roll - deg"
  # ) +
  #   geom_point(alpha = 1),
  # plot_3var(
  #   custom, "Y) Custom - position x y and roll",
  #   custom$position_x-min(custom$position_x), c(0, floor(max(custom$position_x-min(custom$position_x)))+1, 100), "position x - m",
  #   custom$position_y-min(custom$position_y), c(0, floor(max(custom$position_y-min(custom$position_y)))+1, 100), "position y - m",
  #   custom$position_r_norm, calc_scale(c(raw$position_rp_norm, custom$position_r_norm, custom_elevation$position_r_norm)), "roll - deg"
  # ) +
  #   geom_point(alpha = 1),
  # plot_3var(
  #   custom_elevation, "Z) Custom elevation - position x y and roll",
  #   custom_elevation$position_x-min(custom_elevation$position_x), c(0, floor(max(custom_elevation$position_x-min(custom_elevation$position_x)))+1, 100), "position x - m",
  #   custom_elevation$position_y-min(custom_elevation$position_y), c(0, floor(max(custom_elevation$position_y-min(custom_elevation$position_y)))+1, 100), "position y - m",
  #   custom_elevation$position_r_norm, calc_scale(c(raw$position_r_norm, custom$position_r_norm, custom_elevation$position_r_norm)), "roll - deg"
  # ) +
  #   geom_point(alpha = 1),
  # plot_3var(
  #   raw, "X) Raw - position x y and yaw",
  #   raw$position_x-min(raw$position_x), c(0, floor(max(raw$position_x-min(raw$position_x)))+1, 100), "position x - m",
  #   raw$position_y-min(raw$position_y), c(0, floor(max(raw$position_y-min(raw$position_y)))+1, 100), "position y - m",
  #   raw$position_h_norm, c(-180, 180, 45), "yaw - deg"
  # ) +
  #   geom_point(alpha = 1),
  # plot_3var(
  #   custom, "Y) Custom - position x y and yaw",
  #   custom$position_x-min(custom$position_x), c(0, floor(max(custom$position_x-min(custom$position_x)))+1, 100), "position x - m",
  #   custom$position_y-min(custom$position_y), c(0, floor(max(custom$position_y-min(custom$position_y)))+1, 100), "position y - m",
  #   custom$position_h_norm, c(-180, 180, 45), "yaw - deg"
  # ) +
  #   geom_point(alpha = 1),
  # plot_3var(
  #   custom_elevation, "Z) Custom elevation - position x y and yaw",
  #   custom_elevation$position_x-min(custom_elevation$position_x), c(0, floor(max(custom_elevation$position_x-min(custom_elevation$position_x)))+1, 100), "position x - m",
  #   custom_elevation$position_y-min(custom_elevation$position_y), c(0, floor(max(custom_elevation$position_y-min(custom_elevation$position_y)))+1, 100), "position y - m",
  #   custom_elevation$position_h_norm, c(-180, 180, 45), "yaw - deg"
  # ) +
  #   geom_point(alpha = 1),
  plot_2var(
    raw, "A) Raw - pitch",
    raw$time-min(raw$time), c(0, floor(max(raw$time-min(raw$time)))+1, 10), "time - s",
    raw$position_p_norm, calc_scale(c(raw$position_p_norm, custom$position_p_norm, custom_elevation$position_p_norm)), "pitch - deg"
  ) +
    geom_line(color="#6B9EE1"),
  plot_2var(
    custom, "B) Custom - pitch",
    custom$time-min(custom$time), c(0, floor(max(custom$time-min(custom$time)))+1, 10), "time - s",
    custom$position_p_norm, calc_scale(c(raw$position_p_norm, custom$position_p_norm, custom_elevation$position_p_norm)), "pitch - deg"
  ) +
    geom_line(color="#6B9EE1"),
  plot_2var(
    custom_elevation, "C) Custom elevation - pitch",
    custom_elevation$time-min(custom_elevation$time), c(0, floor(max(custom_elevation$time-min(custom_elevation$time)))+1, 10), "time - s",
    custom_elevation$position_p_norm, calc_scale(c(raw$position_p_norm, custom$position_p_norm, custom_elevation$position_p_norm)), "pitch - deg"
  ) +
    geom_line(color="#6B9EE1"),
  plot_2var(
    raw, "D) Raw - roll",
    raw$time-min(raw$time), c(0, floor(max(raw$time-min(raw$time)))+1, 10), "time - s",
    raw$position_r_norm, calc_scale(c(raw$position_r_norm, custom$position_r_norm, custom_elevation$position_r_norm)), "roll - deg"
  ) +
    geom_line(color="#6B9EE1"),
  plot_2var(
    custom, "E) Custom - roll",
    custom$time-min(custom$time), c(0, floor(max(custom$time-min(custom$time)))+1, 10), "time - s",
    custom$position_r_norm, calc_scale(c(raw$position_r_norm, custom$position_r_norm, custom_elevation$position_r_norm)), "roll - deg"
  ) +
    geom_line(color="#6B9EE1"),
  plot_2var(
    custom_elevation, "F) Custom elevation - roll",
    custom_elevation$time-min(custom_elevation$time), c(0, floor(max(custom_elevation$time-min(custom_elevation$time)))+1, 10), "time - s",
    custom_elevation$position_r_norm, calc_scale(c(raw$position_r_norm, custom$position_r_norm, custom_elevation$position_r_norm)), "roll - deg"
  ) +
    geom_line(color="#6B9EE1"),
  plot_2var(
    raw, "G) Raw - yaw",
    raw$time-min(raw$time), c(0, floor(max(raw$time-min(raw$time)))+1, 10), "time - s",
    raw$position_h_norm, c(-180, 180, 45), "yaw - deg"
  ) +
    geom_line(color="#6B9EE1"),
  plot_2var(
    custom, "H) Custom - yaw",
    custom$time-min(custom$time), c(0, floor(max(custom$time-min(custom$time)))+1, 10), "time - s",
    custom$position_h_norm, c(-180, 180, 45), "yaw - deg"
  ) +
    geom_line(color="#6B9EE1"),
  plot_2var(
    custom_elevation, "I) Custom elevation - yaw",
    custom_elevation$time-min(custom_elevation$time), c(0, floor(max(custom_elevation$time-min(custom_elevation$time)))+1, 10), "time - s",
    custom_elevation$position_h_norm, c(-180, 180, 45), "yaw - deg"
  ) +
    geom_line(color="#6B9EE1"),
  nrow = 3, ncol = 3), width = 10*3, height = 5*3)

#speed
ggsave("output/speed.png", grid.arrange(
  plot_3var(
    raw, "A) Raw - position x y and speed spatial",
    raw$position_x-min(raw$position_x), c(0, floor(max(raw$position_x-min(raw$position_x)))+1, 100), "position x - m",
    raw$position_y-min(raw$position_y), c(0, floor(max(raw$position_y-min(raw$position_y)))+1, 100), "position y - m",
    raw$speed_spatial_norm, c(0, floor(max(raw$speed_spatial_norm))+1, 20), "speed spatial - km/h"
  ) +
    geom_point(alpha = 1),
  plot_3var(
    custom, "B) Custom - position x y and speed spatial",
    custom$position_x-min(custom$position_x), c(0, floor(max(custom$position_x-min(custom$position_x)))+1, 100), "position x - m",
    custom$position_y-min(custom$position_y), c(0, floor(max(custom$position_y-min(custom$position_y)))+1, 100), "position y - m",
    custom$speed_spatial_norm, c(0, floor(max(custom$speed_spatial_norm))+1, 20), "speed spatial - km/h"
  ) +
    geom_point(alpha = 1),
  plot_3var(
    custom_elevation, "C) Custom elevation - position x y and speed spatial",
    custom_elevation$position_x-min(custom_elevation$position_x), c(0, floor(max(custom_elevation$position_x-min(custom_elevation$position_x)))+1, 100), "position x - m",
    custom_elevation$position_y-min(custom_elevation$position_y), c(0, floor(max(custom_elevation$position_y-min(custom_elevation$position_y)))+1, 100), "position y - m",
    custom_elevation$speed_spatial_norm, c(0, floor(max(custom_elevation$speed_spatial_norm))+1, 20), "speed spatial - km/h"
  ) +
    geom_point(alpha = 1),
  plot_2var(
    raw, "D) Raw - speed planar and spatial",
    raw$time-min(raw$time), c(0, floor(max(raw$time-min(raw$time)))+1, 10), "time - s",
    raw$speed_spatial_norm, c(0, floor(max(raw$speed_spatial_norm))+1, 20), "speed planar and spatial"
  ) +
    geom_line(aes(y = raw$speed_planar_norm, color = "speed planar")) +
    geom_line(aes(y = raw$speed_spatial_norm, color = "speed spatial")) +
    scale_color_manual(values = c("speed planar" = "#86F5FA", "speed spatial" = "#6B9EE1")) +
    labs(color = "speed - km/h"),
  plot_2var(
    custom, "E) Custom - speed planar and spatial",
    custom$time-min(custom$time), c(0, floor(max(custom$time-min(custom$time)))+1, 10), "time - s",
    custom$speed_spatial_norm, c(0, floor(max(custom$speed_spatial_norm))+1, 20), "speed planar and spatial"
  ) +
    geom_line(aes(y = custom$speed_planar_norm, color = "speed planar")) +
    geom_line(aes(y = custom$speed_spatial_norm, color = "speed spatial")) +
    scale_color_manual(values = c("speed planar" = "#86F5FA", "speed spatial" = "#6B9EE1")) +
    labs(color = "speed - km/h"),
  plot_2var(
    custom_elevation, "F) Custom elevation - speed planar and spatial",
    custom_elevation$time-min(custom_elevation$time), c(0, floor(max(custom_elevation$time-min(custom_elevation$time)))+1, 10), "time - s",
    custom_elevation$speed_spatial_norm, c(0, floor(max(custom_elevation$speed_spatial_norm))+1, 20), "speed planar and spatial"
  ) +
    geom_line(aes(y = custom_elevation$speed_planar_norm, color = "speed planar")) +
    geom_line(aes(y = custom_elevation$speed_spatial_norm, color = "speed spatial")) +
    scale_color_manual(values = c("speed planar" = "#86F5FA", "speed spatial" = "#6B9EE1")) +
    labs(color = "speed - km/h"),
  nrow = 2, ncol = 3), width = 10*3, height = 5*2)

#acceleration
ggsave("output/acceleration.png", grid.arrange(
  plot_3var(
    raw, "A) Raw - acceleration x y and z",
    raw$acceleration_x_norm, c(calc_scale(c(raw$acceleration_x_norm, raw$acceleration_y_norm))[c(1,2)], 1), "acceleration x - G",
    raw$acceleration_y_norm, c(calc_scale(c(raw$acceleration_x_norm, raw$acceleration_y_norm))[c(1,2)], 1), "acceleration y - G",
    raw$acceleration_z_norm, c(floor(min(raw$acceleration_z_norm)), floor(max(raw$acceleration_z_norm))+1, 1), "acceleration z - G"
  ) +
    geom_point(alpha = 1),
  plot_3var(
    custom, "B) Custom - acceleration x y and z",
    custom$acceleration_x_norm, c(calc_scale(c(custom$acceleration_x_norm, custom$acceleration_y_norm))[c(1,2)], 1), "acceleration x - G",
    custom$acceleration_y_norm, c(calc_scale(c(custom$acceleration_x_norm, custom$acceleration_y_norm))[c(1,2)], 1), "acceleration y - G",
    custom$acceleration_z_norm, c(floor(min(custom$acceleration_z_norm)), floor(max(custom$acceleration_z_norm))+1, 1), "acceleration z - G"
  ) +
    geom_point(alpha = 1),
  plot_3var(
    custom_elevation, "C) Custom elevation - acceleration x y and z",
    custom_elevation$acceleration_x_norm, c(calc_scale(c(custom_elevation$acceleration_x_norm, custom_elevation$acceleration_y_norm))[c(1,2)], 1), "acceleration x - G",
    custom_elevation$acceleration_y_norm, c(calc_scale(c(custom_elevation$acceleration_x_norm, custom_elevation$acceleration_y_norm))[c(1,2)], 1), "acceleration y - G",
    custom_elevation$acceleration_z_norm, c(floor(min(custom_elevation$acceleration_z_norm)), floor(max(custom_elevation$acceleration_z_norm))+1, 1), "acceleration z - G"
  ) +
    geom_point(alpha = 1),
  plot_2var(
    raw, "D) Raw - acceleration x y and z",
    raw$time-min(raw$time), c(0, floor(max(raw$time-min(raw$time)))+1, 10), "time - s",
    raw$acceleration_x_norm, c(calc_scale(c(raw$acceleration_x_norm, raw$acceleration_y_norm))[c(1,2)], 1), "acceleration planar and spatial"
  ) +
    geom_line(aes(y = raw$acceleration_x_norm, color = "acceleration x")) +
    geom_line(aes(y = raw$acceleration_y_norm, color = "acceleration y")) +
    geom_line(aes(y = raw$acceleration_z_norm, color = "acceleration z")) +
    scale_color_manual(values = c("acceleration x" = "#86F5FA", "acceleration y" = "#79CAEE", "acceleration z" = "#6B9EE1")) +
    labs(color = "acceleration - G"),
  plot_2var(
    custom, "E) Custom - acceleration x y and z",
    custom$time-min(custom$time), c(0, floor(max(custom$time-min(custom$time)))+1, 10), "time - s",
    custom$acceleration_x_norm, c(calc_scale(c(custom$acceleration_x_norm, custom$acceleration_y_norm))[c(1,2)], 1), "acceleration planar and spatial"
  ) +
    geom_line(aes(y = custom$acceleration_x_norm, color = "acceleration x")) +
    geom_line(aes(y = custom$acceleration_y_norm, color = "acceleration y")) +
    geom_line(aes(y = custom$acceleration_z_norm, color = "acceleration z")) +
    scale_color_manual(values = c("acceleration x" = "#86F5FA", "acceleration y" = "#79CAEE", "acceleration z" = "#6B9EE1")) +
    labs(color = "acceleration - G"),
  plot_2var(
    custom_elevation, "F) Custom elevation - acceleration x y and z",
    custom_elevation$time-min(custom_elevation$time), c(0, floor(max(custom_elevation$time-min(custom_elevation$time)))+1, 10), "time - s",
    custom_elevation$acceleration_x_norm, c(calc_scale(c(custom_elevation$acceleration_x_norm, custom_elevation$acceleration_y_norm))[c(1,2)], 1), "acceleration planar and spatial"
  ) +
    geom_line(aes(y = custom_elevation$acceleration_x_norm, color = "acceleration x")) +
    geom_line(aes(y = custom_elevation$acceleration_y_norm, color = "acceleration y")) +
    geom_line(aes(y = custom_elevation$acceleration_z_norm, color = "acceleration z")) +
    scale_color_manual(values = c("acceleration x" = "#86F5FA", "acceleration y" = "#79CAEE", "acceleration z" = "#6B9EE1")) +
    labs(color = "acceleration - G"),
  # plot_3var(
  #   raw, "X) Raw - position x y and acceleration spatial",
  #   raw$position_x-min(raw$position_x), c(0, floor(max(raw$position_x-min(raw$position_x)))+1, 100), "position x - m",
  #   raw$position_y-min(raw$position_y), c(0, floor(max(raw$position_y-min(raw$position_y)))+1, 100), "position y - m",
  #   raw$acceleration_spatial_norm, c(floor(min(raw$acceleration_spatial_norm)), floor(max(raw$acceleration_spatial_norm))+1, 1), "acceleration spatial - G"
  # ) +
  #   geom_point(alpha = 1),
  # plot_3var(
  #   custom, "Y) Custom - position x y and acceleration spatial",
  #   custom$position_x-min(custom$position_x), c(0, floor(max(custom$position_x-min(custom$position_x)))+1, 100), "position x - m",
  #   custom$position_y-min(custom$position_y), c(0, floor(max(custom$position_y-min(custom$position_y)))+1, 100), "position y - m",
  #   custom$acceleration_spatial_norm, c(floor(min(custom$acceleration_spatial_norm)), floor(max(custom$acceleration_spatial_norm))+1, 1), "acceleration spatial - G"
  # ) +
  #   geom_point(alpha = 1),
  # plot_3var(
  #   custom_elevation, "Z) Custom elevation - position x y and acceleration spatial",
  #   custom_elevation$position_x-min(custom_elevation$position_x), c(0, floor(max(custom_elevation$position_x-min(custom_elevation$position_x)))+1, 100), "position x - m",
  #   custom_elevation$position_y-min(custom_elevation$position_y), c(0, floor(max(custom_elevation$position_y-min(custom_elevation$position_y)))+1, 100), "position y - m",
  #   custom_elevation$acceleration_spatial_norm, c(floor(min(custom_elevation$acceleration_spatial_norm)), floor(max(custom_elevation$acceleration_spatial_norm))+1, 1), "acceleration spatial - G"
  # ) +
  #   geom_point(alpha = 1),
  plot_2var(
    raw, "G) Raw - acceleration planar and spatial",
    raw$time-min(raw$time), c(0, floor(max(raw$time-min(raw$time)))+1, 10), "time - s",
    raw$acceleration_spatial_norm, c(floor(min(raw$acceleration_spatial_norm)), floor(max(raw$acceleration_spatial_norm))+1, 1), "acceleration planar and spatial"
  ) +
    geom_line(aes(y = raw$acceleration_planar_norm, color = "acceleration planar")) +
    geom_line(aes(y = raw$acceleration_spatial_norm, color = "acceleration spatial")) +
    scale_color_manual(values = c("acceleration planar" = "#86F5FA", "acceleration spatial" = "#6B9EE1")) +
    labs(color = "acceleration - G"),
  plot_2var(
    custom, "H) Custom - acceleration planar and spatial",
    custom$time-min(custom$time), c(0, floor(max(custom$time-min(custom$time)))+1, 10), "time - s",
    custom$acceleration_spatial_norm, c(floor(min(custom$acceleration_spatial_norm)), floor(max(custom$acceleration_spatial_norm))+1, 1), "acceleration planar and spatial"
  ) +
    geom_line(aes(y = custom$acceleration_planar_norm, color = "acceleration planar")) +
    geom_line(aes(y = custom$acceleration_spatial_norm, color = "acceleration spatial")) +
    scale_color_manual(values = c("acceleration planar" = "#86F5FA", "acceleration spatial" = "#6B9EE1")) +
    labs(color = "acceleration - G"),
  plot_2var(
    custom_elevation, "I) Custom elevation - acceleration planar and spatial",
    custom_elevation$time-min(custom_elevation$time), c(0, floor(max(custom_elevation$time-min(custom_elevation$time)))+1, 10), "time - s",
    custom_elevation$acceleration_spatial_norm, c(floor(min(custom_elevation$acceleration_spatial_norm)), floor(max(custom_elevation$acceleration_spatial_norm))+1, 1), "acceleration planar and spatial"
  ) +
    geom_line(aes(y = custom_elevation$acceleration_planar_norm, color = "acceleration planar")) +
    geom_line(aes(y = custom_elevation$acceleration_spatial_norm, color = "acceleration spatial")) +
    scale_color_manual(values = c("acceleration planar" = "#86F5FA", "acceleration spatial" = "#6B9EE1")) +
    labs(color = "acceleration - G"),
  nrow = 3, ncol = 3), width = 10*3, height = 5*3)

#distance
ggsave("output/distance.png", grid.arrange(
  # plot_3var(
  #   raw, "X) Raw - position x y and distance spatial",
  #   raw$position_x-min(raw$position_x), c(0, floor(max(raw$position_x-min(raw$position_x)))+1, 100), "position x - m",
  #   raw$position_y-min(raw$position_y), c(0, floor(max(raw$position_y-min(raw$position_y)))+1, 100), "position y - m",
  #   raw$dist_spatial, c(0, floor(max(raw$dist_spatial))+1, 100), "distance spatial - m"
  # ) +
  #   geom_point(alpha = 1),
  # plot_3var(
  #   custom, "Y) Custom - position x y and distance spatial",
  #   custom$position_x-min(custom$position_x), c(0, floor(max(custom$position_x-min(custom$position_x)))+1, 100), "position x - m",
  #   custom$position_y-min(custom$position_y), c(0, floor(max(custom$position_y-min(custom$position_y)))+1, 100), "position y - m",
  #   custom$dist_spatial, c(0, floor(max(custom$dist_spatial))+1, 100), "distance spatial - m"
  # ) +
  #   geom_point(alpha = 1),
  # plot_3var(
  #   custom_elevation, "Z) Custom elevation - position x y and distance spatial",
  #   custom_elevation$position_x-min(custom_elevation$position_x), c(0, floor(max(custom_elevation$position_x-min(custom_elevation$position_x)))+1, 100), "position x - m",
  #   custom_elevation$position_y-min(custom_elevation$position_y), c(0, floor(max(custom_elevation$position_y-min(custom_elevation$position_y)))+1, 100), "position y - m",
  #   custom_elevation$dist_spatial, c(0, floor(max(custom_elevation$dist_spatial))+1, 100), "distance spatial - m"
  # ) +
  #   geom_point(alpha = 1),
  plot_2var(
    raw, "A) Raw - distance planar and spatial",
    raw$time-min(raw$time), c(0, floor(max(raw$time-min(raw$time)))+1, 10), "time - s",
    raw$dist_spatial, c(0, floor(max(raw$dist_spatial))+1, 100), "distance planar and spatial"
  ) +
    geom_line(aes(y = raw$dist_planar, color = "distance planar")) +
    geom_line(aes(y = raw$dist_spatial, color = "distance spatial")) +
    scale_color_manual(values = c("distance planar" = "#86F5FA", "distance spatial" = "#6B9EE1")) +
    labs(color = "distance - m"),
  plot_2var(
    custom, "B) Custom - distance planar and spatial",
    custom$time-min(custom$time), c(0, floor(max(custom$time-min(custom$time)))+1, 10), "time - s",
    custom$dist_spatial, c(0, floor(max(custom$dist_spatial))+1, 100), "distance planar and spatial"
  ) +
    geom_line(aes(y = custom$dist_planar, color = "distance planar")) +
    geom_line(aes(y = custom$dist_spatial, color = "distance spatial")) +
    scale_color_manual(values = c("distance planar" = "#86F5FA", "distance spatial" = "#6B9EE1")) +
    labs(color = "distance - m"),
  plot_2var(
    custom_elevation, "C) Custom elevation - distance planar and spatial",
    custom_elevation$time-min(custom_elevation$time), c(0, floor(max(custom_elevation$time-min(custom_elevation$time)))+1, 10), "time - s",
    custom_elevation$dist_spatial, c(0, floor(max(custom_elevation$dist_spatial))+1, 100), "distance planar and spatial"
  ) +
    geom_line(aes(y = custom_elevation$dist_planar, color = "distance planar")) +
    geom_line(aes(y = custom_elevation$dist_spatial, color = "distance spatial")) +
    scale_color_manual(values = c("distance planar" = "#86F5FA", "distance spatial" = "#6B9EE1")) +
    labs(color = "distance - m"),
  nrow = 1, ncol = 3), width = 10*3, height = 5*1)

#steering
ggsave("output/steering.png", grid.arrange(
  # plot_3var(
  #   raw, "X) Raw - position x y and steering",
  #   raw$position_x-min(raw$position_x), c(0, floor(max(raw$position_x-min(raw$position_x)))+1, 100), "position x - m",
  #   raw$position_y-min(raw$position_y), c(0, floor(max(raw$position_y-min(raw$position_y)))+1, 100), "position y - m",
  #   raw$steering, c(floor(min(raw$steering)), floor(max(raw$steering))+1, 1), "steering"
  # ) +
  #   geom_point(alpha = 1),
  # plot_3var(
  #   custom, "Y) Custom - position x y and steering",
  #   custom$position_x-min(custom$position_x), c(0, floor(max(custom$position_x-min(custom$position_x)))+1, 100), "position x - m",
  #   custom$position_y-min(custom$position_y), c(0, floor(max(custom$position_y-min(custom$position_y)))+1, 100), "position y - m",
  #   custom$steering, c(floor(min(custom$steering)), floor(max(custom$steering))+1, 1), "steering"
  # ) +
  #   geom_point(alpha = 1),
  # plot_3var(
  #   custom_elevation, "Z) Custom elevation - position x y and steering",
  #   custom_elevation$position_x-min(custom_elevation$position_x), c(0, floor(max(custom_elevation$position_x-min(custom_elevation$position_x)))+1, 100), "position x - m",
  #   custom_elevation$position_y-min(custom_elevation$position_y), c(0, floor(max(custom_elevation$position_y-min(custom_elevation$position_y)))+1, 100), "position y - m",
  #   custom_elevation$steering, c(floor(min(custom_elevation$steering)), floor(max(custom_elevation$steering))+1, 1), "steering"
  # ) +
  #   geom_point(alpha = 1),
  plot_2var(
    raw, "A) Raw - steering",
    raw$time-min(raw$time), c(0, floor(max(raw$time-min(raw$time)))+1, 10), "time - s",
    raw$steering, c(floor(min(raw$steering)), floor(max(raw$steering))+1, 1), "steering"
  ) +
    geom_line(color="#6B9EE1"),
  plot_2var(
    custom, "B) Custom - steering",
    custom$time-min(custom$time), c(0, floor(max(custom$time-min(custom$time)))+1, 10), "time - s",
    custom$steering, c(floor(min(custom$steering)), floor(max(custom$steering))+1, 1), "steering"
  ) +
    geom_line(color="#6B9EE1"),
  plot_2var(
    custom_elevation, "C) Custom elevation - steering",
    custom_elevation$time-min(custom_elevation$time), c(0, floor(max(custom_elevation$time-min(custom_elevation$time)))+1, 10), "time - s",
    custom_elevation$steering, c(floor(min(custom_elevation$steering)), floor(max(custom_elevation$steering))+1, 1), "steering"
  ) +
    geom_line(color="#6B9EE1"),
  nrow = 1, ncol = 3), width = 10*3, height = 5*1)

#distance from reference
ggsave("output/distance reference.png", grid.arrange(
  plot_2var(
    road_raw, "A) Raw - distance from reference",
    road_raw$x-min(road_raw$x), c(0, floor(max(raw$position_x-min(raw$position_x)))+1, 100), "position x - m",
    road_raw$y-min(road_raw$y), c(0, floor(max(raw$position_y-min(raw$position_y)))+1, 100), "position y - m"
  ) +
    geom_point(aes(x = road_raw$x-min(road_raw$x), y = road_raw$y-min(road_raw$y), color = "reference")) +
    geom_point(aes(x = c(raw$position_x-min(road_raw$x), rep(NA, length(road_raw$x)-length(raw$position_x))), y = c(raw$position_y-min(road_raw$y), rep(NA, length(road_raw$y)-length(raw$position_y))), color = "test")) +
    scale_color_manual(values = c("reference" = "#86F5FA", "test" = "#6B9EE1")) +
    labs(color = "road"),
  plot_2var(
    road_custom, "B) Custom - distance from reference",
    road_custom$x-min(road_custom$x), c(0, floor(max(road_custom$x-min(road_custom$x)))+1, 100), "position x - m",
    road_custom$y-min(road_custom$y), c(0, floor(max(road_custom$y-min(road_custom$y)))+1, 100), "position y - m"
  ) +
    geom_point(aes(x = road_custom$x-min(road_custom$x), y = road_custom$y-min(road_custom$y), color = "reference")) +
    geom_point(aes(x = c(custom$position_x-min(road_custom$x), rep(NA, length(road_custom$x)-length(custom$position_x))), y = c(custom$position_y-min(road_custom$y), rep(NA, length(road_custom$y)-length(custom$position_y))), color = "test")) +
    scale_color_manual(values = c("reference" = "#86F5FA", "test" = "#6B9EE1")) +
    labs(color = "road"),
  plot_2var(
    road_custom_elevation, "C) Custom elevation - distance from reference",
    road_custom_elevation$x-min(road_custom_elevation$x), c(0, floor(max(road_custom_elevation$x-min(road_custom_elevation$x)))+1, 100), "position x - m",
    road_custom_elevation$y-min(road_custom_elevation$y), c(0, floor(max(road_custom_elevation$y-min(road_custom_elevation$y)))+1, 100), "position y - m"
  ) +
    geom_point(aes(x = road_custom_elevation$x-min(road_custom_elevation$x), y = road_custom_elevation$y-min(road_custom_elevation$y), color = "reference")) +
    geom_point(aes(x = c(custom_elevation$position_x-min(road_custom_elevation$x), rep(NA, length(road_custom_elevation$x)-length(custom_elevation$position_x))), y = c(custom_elevation$position_y-min(road_custom_elevation$y), rep(NA, length(road_custom_elevation$y)-length(custom_elevation$position_y))), color = "test")) +
    scale_color_manual(values = c("reference" = "#86F5FA", "test" = "#6B9EE1")) +
    labs(color = "road"),
  plot_2var(
    raw, "D) Raw - distance from reference",
    raw$time-min(raw$time), c(0, floor(max(raw$time-min(raw$time)))+1, 10), "time - s",
    raw$dist_reference, c(0, max(floor(max(raw$dist_reference))+1, lane_width_raw), 100), "distance from reference - m"
  ) +
    geom_line(color="#6B9EE1") +
    geom_hline(aes(yintercept = lane_width_raw), color="#86F5FA") +
    geom_vline(data = raw %>% filter(road_id != lag(road_id, default = first(road_id))) %>% select(time), aes(xintercept = time), color = "#86F5FA"),
  plot_2var(
    custom, "E) Custom - distance from reference",
    custom$time-min(custom$time), c(0, floor(max(custom$time-min(custom$time)))+1, 10), "time - s",
    custom$dist_reference, c(0, max(floor(max(custom$dist_reference))+1, lane_width_custom), 1), "distance from reference - m"
  ) +
    geom_line(color="#6B9EE1") +
    geom_hline(aes(yintercept = lane_width_custom), color="#86F5FA") +
    geom_vline(data = custom %>% filter(road_id != lag(road_id, default = first(road_id))) %>% select(time), aes(xintercept = time), color = "#86F5FA"),
  plot_2var(
    custom_elevation, "F) Custom elevation - distance from reference",
    custom_elevation$time-min(custom_elevation$time), c(0, floor(max(custom_elevation$time-min(custom_elevation$time)))+1, 10), "time - s",
    custom_elevation$dist_reference, c(0, max(floor(max(custom_elevation$dist_reference))+1, lane_width_custom_elevation), 1), "distance from reference - m"
  ) +
    geom_line(color="#6B9EE1") +
    geom_hline(aes(yintercept = lane_width_custom_elevation), color="#86F5FA") +
    geom_vline(data = custom_elevation %>% filter(road_id != lag(road_id, default = first(road_id))) %>% select(time), aes(xintercept = time), color = "#86F5FA"),
  nrow = 2, ncol = 3), width = 10*3, height = 5*2)

```

# Distance from reference

```{r}
#We proceed with the analysis of how road generator influences the average distance form reference
#We study how dist_reference varies with dataset
summary(raw$dist_reference)
sd(raw$dist_reference)
skewness(raw$dist_reference)
kurtosis(raw$dist_reference)
summary(custom$dist_reference)
sd(custom$dist_reference)
skewness(custom$dist_reference)
kurtosis(custom$dist_reference)
summary(custom_elevation$dist_reference)
sd(custom_elevation$dist_reference)
skewness(custom_elevation$dist_reference)
kurtosis(custom_elevation$dist_reference)
par(mfrow=c(1,3))
boxplot(raw$dist_reference, main="Raw", horizontal=F)
boxplot(custom$dist_reference, main="Custom", horizontal=F)
boxplot(custom_elevation$dist_reference, main="Custom elevation", horizontal=F)
par(mfrow=c(1,1))
#From the output it can be deduced for dist_reference given raw, custom and custom_elevation
#- from the summary there is right asymmetry (median more than mean)
#- from boxplot, it confirms what said above because both the median is in the upper part of the box of 1st and 3rd quartile and the two minimum and maximum lines have different lengths (maximum longer than minimum) and there are some outliers

#Then, a test is carried out on the difference in the means of two independent populations.
#First it is checked whether the two variables have a normal distribution through the qqplots.
par(mfrow=c(1,3))
qqnorm(raw$dist_reference, main="Raw")
qqline(raw$dist_reference)
qqnorm(custom$dist_reference, main="Custom")
qqline(custom$dist_reference)
qqnorm(custom_elevation$dist_reference, main="Custom elevation")
qqline(custom_elevation$dist_reference)
par(mfrow=c(1,1))
#From the output it can be deduced for dist_reference given raw, custom and custom_elevation
#- from the qqpolt (graph that relates the quatiles of the normal and the quantiles of the given distribution), it can be seen that the two distributions are not normal due to the tails (both) which do not follow the straight line

#Then, a test for equality of variances is performed. This test can be used even if the two variables are not normal as the sample size is sufficiently large.
#test between raw and custom
var.test(raw$dist_reference, custom$dist_reference, conf.level = 0.99, alternative = c("two.sided"))
#test between custom and custom_elevation
var.test(custom$dist_reference, custom_elevation$dist_reference, conf.level = 0.99, alternative = c("two.sided"))
#From the output it can be deduced for dist_reference given raw and custom
#- from the test of equality of variances, with 99% confidence the two variances can be considered different and also the extremely low p-value (less than 2.2e-16) reinforces the decision to decisively reject the hypothesis that the variances are equal
#also for dist_reference given custom and custom_elevation
#- from the test of equality of variances, with 99% confidence the two variances can be considered different and also the high p-value (0.88) reinforces the decision to accept the hypothesis that the variances are equal

#Therefore it is possible to carry out a test on the equality of the means by imposing the condition that the variance of the populations is unknown and different (or with same) in the two populations.
#test between raw and custom
t.test(raw$dist_reference, custom$dist_reference, conf.level = 0.99, alternative = c("two.sided"), mu=0, var.equal = F)
#test between custom and custom_elevation
t.test(custom$dist_reference, custom_elevation$dist_reference, conf.level = 0.99, alternative = c("two.sided"), mu=0, var.equal = T)
#From the output it can be deduced for dist_reference given raw and custom
#- from the test of equality of means, with 99% confidence the two means can be considered different and also the high p-value (0.40) reinforces the decision to decisively reject the hypothesis that the means are equal
#also for dist_reference given custom and custom_elevation
#- from the test of equality of means, with 99% confidence the two means can be considered different and also the high p-value (0.87) reinforces the decision to accept the hypothesis that the means are equal

#so the custom road generator influences the variance distance form reference, but the elevation doesn't influence the variance; the road generator doesn't influence the mean distance form reference.

```

# Steering

```{r}
#We proceed with the analysis of how road generator influences the average steering
#We study how steering varies with dataset
summary(raw$steering)
sd(raw$steering)
skewness(raw$steering)
kurtosis(raw$steering)
summary(custom$steering)
sd(custom$steering)
skewness(custom$steering)
kurtosis(custom$steering)
summary(custom_elevation$steering)
sd(custom_elevation$steering)
skewness(custom_elevation$steering)
kurtosis(custom_elevation$steering)
par(mfrow=c(1,3))
boxplot(raw$steering, main="Raw", horizontal=F)
boxplot(custom$steering, main="Custom", horizontal=F)
boxplot(custom_elevation$steering, main="Custom elevation", horizontal=F)
par(mfrow=c(1,1))
#From the output it can be deduced for steering given raw, custom and custom_elevation
#- from the summary there is right asymmetry (median more than mean)
#- from boxplot, it confirms what said above because the median is in the upper part of the box of 1st and 3rd quartile and there are outliers

#Then, a test is carried out on the difference in the means of two independent populations.
#First it is checked whether the two variables have a normal distribution through the qqplots.
par(mfrow=c(1,3))
qqnorm(raw$steering, main="Raw")
qqline(raw$steering)
qqnorm(custom$steering, main="Custom")
qqline(custom$steering)
qqnorm(custom_elevation$steering, main="Custom elevation")
qqline(custom_elevation$steering)
par(mfrow=c(1,1))
#From the output it can be deduced for steering given raw, custom and custom_elevation
#- from the qqplot, it can be seen that the distribution in not normal due to the tails (both) which do not follow the straight line and also the main part of the distribution doesn't follow the straight line

#Then, a test for equality of variances is performed. This test can be used even if the two variables are not normal as the sample size is sufficiently large.
#test between raw and custom
var.test(raw$steering, custom$steering, conf.level = 0.99, alternative = c("two.sided"))
#test between custom and custom_elevation
var.test(custom$steering, custom_elevation$steering, conf.level = 0.99, alternative = c("two.sided"))
#From the output it can be deduced for steering given raw and custom
#- from the test of equality of variances, with 99% confidence the two variances can be considered different and also the extremely low p-value (4.41e-9) reinforces the decision to decisively reject the hypothesis that the variances are equal
#also for steering given custom and custom_elevation
#- from the test of equality of variances, with 99% confidence the two variances can be considered different and also the high p-value (0.93) reinforces the decision to accept the hypothesis that the variances are equal

#Therefore it is possible to carry out a test on the equality of the means by imposing the condition that the variance of the populations is unknown and different (or with same) in the two populations.
#test between raw and custom
t.test(raw$steering, custom$steering, conf.level = 0.99, alternative = c("two.sided"), mu=0, var.equal = F)
#test between custom and custom_elevation
t.test(custom$steering, custom_elevation$steering, conf.level = 0.99, alternative = c("two.sided"), mu=0, var.equal = T)
#From the output it can be deduced for steering given raw and custom
#- from the test of equality of means, with 99% confidence the two means can be considered different and also the high p-value (0.04) reinforces the decision to reject with reservation the hypothesis that the means are equal
#also for steering given custom and custom_elevation
#- from the test of equality of means, with 99% confidence the two means can be considered different and also the high p-value (0.77) reinforces the decision to accept the hypothesis that the means are equal

#so the custom road generator influences the mean steering, but the elevation doesn't influence the steering.

```

# Distance planar, diatance spatial

```{r}
#We proceed with the analysis of how road generator influences the average distance 2D
#We study how dist_planar varies with dataset
summary(raw$dist_planar)
sd(raw$dist_planar)
skewness(raw$dist_planar)
kurtosis(raw$dist_planar)
summary(custom$dist_planar)
sd(custom$dist_planar)
skewness(custom$dist_planar)
kurtosis(custom$dist_planar)
summary(custom_elevation$dist_planar)
sd(custom_elevation$dist_planar)
skewness(custom_elevation$dist_planar)
kurtosis(custom_elevation$dist_planar)
par(mfrow=c(1,3))
boxplot(raw$dist_planar, main="Raw", horizontal=F)
boxplot(custom$dist_planar, main="Custom", horizontal=F)
boxplot(custom_elevation$dist_planar, main="Custom elevation", horizontal=F)
par(mfrow=c(1,1))
#From the output it can be deduced for dist_planar given raw, custom and custom_elevation
#- from the summary there is right asymmetry (median more than mean), for both custom and custom_elevation
#- from boxplot, it confirms what said above because the median is in the upper part of the box of 1st and 3rd quartile

#Then, a test is carried out on the difference in the means of two independent populations.
#First it is checked whether the two variables have a normal distribution through the qqplots.
par(mfrow=c(1,3))
qqnorm(raw$dist_planar, main="Raw")
qqline(raw$dist_planar)
qqnorm(custom$dist_planar, main="Custom")
qqline(custom$dist_planar)
qqnorm(custom_elevation$dist_planar, main="Custom elevation")
qqline(custom_elevation$dist_planar)
par(mfrow=c(1,1))
#From the output it can be deduced for dist_planar given raw, custom and custom_elevation
#- from the qqplot, it can be seen that the distribution in not normal due to the tails (both) which do not follow the straight line

#Then, a test for equality of variances is performed. This test can be used even if the two variables are not normal as the sample size is sufficiently large.
#test between raw and custom
var.test(raw$dist_planar, custom$dist_planar, conf.level = 0.99, alternative = c("two.sided"))
#test between custom and custom_elevation
var.test(custom$dist_planar, custom_elevation$dist_planar, conf.level = 0.99, alternative = c("two.sided"))
#From the output it can be deduced for dist_planar given raw and custom
#- from the test of equality of variances, with 99% confidence the two variances can be considered different and also the high p-value (0.56) reinforces the decision to accept the hypothesis that the variances are equal
#also for dist_planar given custom and custom_elevation
#- from the test of equality of variances, with 99% confidence the two variances can be considered equal and also the high p-value (0.77) reinforces the decision to accept the hypothesis that the variances are equal

#Therefore it is possible to carry out a test on the equality of the means by imposing the condition that the variance of the populations is unknown and with same variance in the two populations.
#test between raw and custom
t.test(raw$dist_planar, custom$dist_planar, conf.level = 0.99, alternative = c("two.sided"), mu=0, var.equal = T)
#test between custom and custom_elevation
t.test(custom$dist_planar, custom_elevation$dist_planar, conf.level = 0.99, alternative = c("two.sided"), mu=0, var.equal = T)
#From the output it can be deduced for dist_planar given raw and custom
#- from the test of equality of means, with 99% confidence the two means can be considered different and also the high p-value (0.21) reinforces the decision to accept the hypothesis that the means are equal
#also for dist_planar given custom and custom_elevation
#- from the test of equality of means, with 99% confidence the two means can be considered equal and also the high p-value (0.56) reinforces the decision to accept the hypothesis that the means are equal

#so the road generator doesn't influence the average distance 2D (also the variance).

#We proceed with the analysis of how road generator influences the average distance 3D
#We study how dist_planar varies with dataset
summary(raw$dist_spatial)
sd(raw$dist_spatial)
skewness(raw$dist_spatial)
kurtosis(raw$dist_spatial)
summary(custom$dist_spatial)
sd(custom$dist_spatial)
skewness(custom$dist_spatial)
kurtosis(custom$dist_spatial)
summary(custom_elevation$dist_spatial)
sd(custom_elevation$dist_spatial)
skewness(custom_elevation$dist_spatial)
kurtosis(custom_elevation$dist_spatial)
par(mfrow=c(1,3))
boxplot(raw$dist_spatial, main="Raw", horizontal=F)
boxplot(custom$dist_spatial, main="Custom", horizontal=F)
boxplot(custom_elevation$dist_spatial, main="Custom elevation", horizontal=F)
par(mfrow=c(1,1))
#From the output it can be deduced for dist_spatial given raw, custom and custom_elevation
#- from the summary there is right asymmetry (median more than mean), for both custom and custom_elevation
#- from boxplot, it confirms what said above because the median is in the upper part of the box of 1st and 3rd quartile

#Then, a test is carried out on the difference in the means of two independent populations.
#First it is checked whether the two variables have a normal distribution through the qqplots.
par(mfrow=c(1,3))
qqnorm(raw$dist_spatial, main="Raw")
qqline(raw$dist_spatial)
qqnorm(custom$dist_spatial, main="Custom")
qqline(custom$dist_spatial)
qqnorm(custom_elevation$dist_spatial, main="Custom elevation")
qqline(custom_elevation$dist_spatial)
par(mfrow=c(1,1))
#From the output it can be deduced for dist_spatial given raw, custom and custom_elevation
#- from the qqplot, it can be seen that the distribution in not normal due to the tails (both) which do not follow the straight line

#Then, a test for equality of variances is performed. This test can be used even if the two variables are not normal as the sample size is sufficiently large.
#test between raw and custom
var.test(raw$dist_spatial, custom$dist_spatial, conf.level = 0.99, alternative = c("two.sided"))
#test between custom and custom_elevation
var.test(custom$dist_spatial, custom_elevation$dist_spatial, conf.level = 0.99, alternative = c("two.sided"))
#From the output it can be deduced for dist_spatial given raw and custom
#- from the test of equality of variances, with 99% confidence the two variances can be considered different and also the high p-value (0.56) reinforces the decision to decisively reject the hypothesis that the variances are equal
#also for dist_spatial given custom and custom_elevation
#- from the test of equality of variances, with 99% confidence the two variances can be considered equal and also the high p-value (0.77) reinforces the decision to accept the hypothesis that the variances are equal

#Therefore it is possible to carry out a test on the equality of the means by imposing the condition that the variance of the populations is unknown and with same varince in the two populations.
#test between raw and custom
t.test(raw$dist_spatial, custom$dist_spatial, conf.level = 0.99, alternative = c("two.sided"), mu=0, var.equal = T)
#test between custom and custom_elevation
t.test(custom$dist_spatial, custom_elevation$dist_spatial, conf.level = 0.99, alternative = c("two.sided"), mu=0, var.equal = T)
#From the output it can be deduced for dist_spatial given raw and custom
#- from the test of equality of means, with 99% confidence the two means can be considered different and also the high p-value (0.21) reinforces the decision to accept the hypothesis that the means are equal
#also for dist_spatial given custom and custom_elevation
#- from the test of equality of means, with 99% confidence the two means can be considered equal and also the high p-value (0.56) reinforces the decision to accept the hypothesis that the means are equal

#so the road generator doesn't influence the average distance 3D (also the variance).

```

# Speed planar, speed spatial

```{r}
#We proceed with the analysis of how road generator influences the average speed 2D
#We study how speed_planar varies with dataset
summary(raw$speed_planar)
sd(raw$speed_planar)
skewness(raw$speed_planar)
kurtosis(raw$speed_planar)
summary(custom$speed_planar)
sd(custom$speed_planar)
skewness(custom$speed_planar)
kurtosis(custom$speed_planar)
summary(custom_elevation$speed_planar)
sd(custom_elevation$speed_planar)
skewness(custom_elevation$speed_planar)
kurtosis(custom_elevation$speed_planar)
par(mfrow=c(1,3))
boxplot(raw$speed_planar, main="Raw", horizontal=F)
boxplot(custom$speed_planar, main="Custom", horizontal=F)
boxplot(custom_elevation$speed_planar, main="Custom elevation", horizontal=F)
par(mfrow=c(1,1))
#From the output it can be deduced for speed_planar given raw, custom, custom_elevation
#- from the summary there is very left asymmetry (median less than mean)
#- from boxplot, it confirms what said above because the median is in the lower part of the box of 1st and 3rd quartile

#Then, a test is carried out on the difference in the means of two independent populations.
#First it is checked whether the two variables have a normal distribution through the qqplots.
par(mfrow=c(1,3))
qqnorm(raw$speed_planar, main="Raw")
qqline(raw$speed_planar)
qqnorm(custom$speed_planar, main="Custom")
qqline(custom$speed_planar)
qqnorm(custom_elevation$speed_planar, main="Custom elevation")
qqline(custom_elevation$speed_planar)
par(mfrow=c(1,1))
#From the output it can be deduced for speed_planar given raw, custom and custom_elevation
#- from the qqplot, it can be seen that the distribution in not normal due to the tails (both) which do not follow the straight line and also the main part of the distribution doesn't follow the straight line

#Then, a test for equality of variances is performed. This test can be used even if the two variables are not normal as the sample size is sufficiently large.
#test between raw and custom
var.test(raw$speed_planar, custom$speed_planar, conf.level = 0.99, alternative = c("two.sided"))
#test between custom and custom_elevation
var.test(custom$speed_planar, custom_elevation$speed_planar, conf.level = 0.99, alternative = c("two.sided"))
#From the output it can be deduced for speed_planar given raw and custom
#- from the test of equality of variances, with 99% confidence the two variances can be considered different and also the extremely low p-value (5.99e-6) reinforces the decision to decisively reject the hypothesis that the variances are equal
#also for speed_planar given custom and custom_elevation
#- from the test of equality of variances, with 99% confidence the two variances can be considered different and also the high p-value (0.95) reinforces the decision to accept the hypothesis that the variances are equal

#Therefore it is possible to carry out a test on the equality of the means by imposing the condition that the variance of the populations is unknown and different (or with same) in the two populations.
#test between raw and custom
t.test(raw$speed_planar, custom$speed_planar, conf.level = 0.99, alternative = c("two.sided"), mu=0, var.equal = F)
#test between custom and custom_elevation
t.test(custom$speed_planar, custom_elevation$speed_planar, conf.level = 0.99, alternative = c("two.sided"), mu=0, var.equal = T)
#From the output it can be deduced for speed_planar given raw and custom
#- from the test of equality of means, with 99% confidence the two means can be considered different and also the low p-value (5.76e-3) reinforces the decision to decisively reject the hypothesis that the means are equal
#also for speed_planar given custom and custom_elevation
#- from the test of equality of means, with 99% confidence the two means can be considered different and also the high p-value (0.83) reinforces the decision to decisively reject the hypothesis that the means are equal

#so the custom road generator influences the average speed 2D (also the variance), but the elevation doesn't influence the speed 2D.

#We proceed with the analysis of how road generator influences the average speed 3D
#We study how speed_spatial varies with dataset
summary(raw$speed_spatial)
sd(raw$speed_spatial)
skewness(raw$speed_spatial)
kurtosis(raw$speed_spatial)
summary(custom$speed_spatial)
sd(custom$speed_spatial)
skewness(custom$speed_spatial)
kurtosis(custom$speed_spatial)
summary(custom_elevation$speed_spatial)
sd(custom_elevation$speed_spatial)
skewness(custom_elevation$speed_spatial)
kurtosis(custom_elevation$speed_spatial)
par(mfrow=c(1,3))
boxplot(raw$speed_spatial, main="Raw", horizontal=F)
boxplot(custom$speed_spatial, main="Custom", horizontal=F)
boxplot(custom_elevation$speed_spatial, main="Custom elevation", horizontal=F)
par(mfrow=c(1,1))
#From the output it can be deduced for speed_spatial given raw, custom, custom_elevation
#- from the summary there is very left asymmetry (median less than mean)
#- from boxplot, it confirms what said above because the median is in the lower part of the box of 1st and 3rd quartile, there are some outliers

#Then, a test is carried out on the difference in the means of two independent populations.
#First it is checked whether the two variables have a normal distribution through the qqplots.
par(mfrow=c(1,3))
qqnorm(raw$speed_spatial, main="Raw")
qqline(raw$speed_spatial)
qqnorm(custom$speed_spatial, main="Custom")
qqline(custom$speed_spatial)
qqnorm(custom_elevation$speed_spatial, main="Custom elevation")
qqline(custom_elevation$speed_spatial)
par(mfrow=c(1,1))
#From the output it can be deduced for speed_spatial given raw, custom and custom_elevation
#- from the qqplot, it can be seen that the distribution in not normal due to the tails (both) which do not follow the straight line and also the main part of the distribution doesn't follow the straight line

#Then, a test for equality of variances is performed. This test can be used even if the two variables are not normal as the sample size is sufficiently large.
#test between raw and custom
var.test(raw$speed_spatial, custom$speed_spatial, conf.level = 0.99, alternative = c("two.sided"))
#test between custom and custom_elevation
var.test(custom$speed_spatial, custom_elevation$speed_spatial, conf.level = 0.99, alternative = c("two.sided"))
#From the output it can be deduced for speed_spatial given raw and custom
#- from the test of equality of variances, with 99% confidence the two variances can be considered different and also the extremely low p-value (5.99e-6) reinforces the decision to decisively reject the hypothesis that the variances are equal
#also for speed_spatial given custom and custom_elevation
#- from the test of equality of variances, with 99% confidence the two variances can be considered different and also the high p-value (0.95) reinforces the decision to accept the hypothesis that the variances are equal

#Therefore it is possible to carry out a test on the equality of the means by imposing the condition that the variance of the populations is unknown and different (or with same) in the two populations.
#test between raw and custom
t.test(raw$speed_spatial, custom$speed_spatial, conf.level = 0.99, alternative = c("two.sided"), mu=0, var.equal = F)
#test between custom and custom_elevation
t.test(custom$speed_spatial, custom_elevation$speed_spatial, conf.level = 0.99, alternative = c("two.sided"), mu=0, var.equal = T)
#From the output it can be deduced for speed_spatial given raw and custom
#- from the test of equality of means, with 99% confidence the two means can be considered different and also the low p-value (5.77e-3) reinforces the decision to decisively reject the hypothesis that the means are equal
#also for speed_spatial given custom and custom_elevation
#- from the test of equality of means, with 99% confidence the two means can be considered different and also the high p-value (0.83) reinforces the decision to accept the hypothesis that the means are equal

#so the custom road generator influences the average speed 3D (also the variance), but the elevation doesn't influence the speed 3D.

```

# Position p, acceleration z

```{r}
#We proceed with the analysis of how road generator influences the pitch
#We study how position_p varies with dataset
summary(raw$position_p)
sd(raw$position_p)
skewness(raw$position_p)
kurtosis(raw$position_p)
summary(custom$position_p)
sd(custom$position_p)
skewness(custom$position_p)
kurtosis(custom$position_p)
summary(custom_elevation$position_p)
sd(custom_elevation$position_p)
skewness(custom_elevation$position_p)
kurtosis(custom_elevation$position_p)
par(mfrow=c(1,3))
boxplot(raw$position_p, main="Raw", horizontal=F)
boxplot(custom$position_p, main="Custom", horizontal=F)
boxplot(custom_elevation$position_p, main="Custom elevation", horizontal=F)
par(mfrow=c(1,1))
#From the output it can be deduced for position_p given raw, custom, custom_elevation
#- from the summary there is left asymmetry (median less than mean)
#- from boxplot, it confirms what said above because the median is in the lower part of the box of 1st and 3rd quartile, there are outliers

#Then, a test is carried out on the difference in the means of two independent populations.
#First it is checked whether the two variables have a normal distribution through the qqplots.
par(mfrow=c(1,3))
qqnorm(raw$position_p, main="Raw")
qqline(raw$position_p)
qqnorm(custom$position_p, main="Custom")
qqline(custom$position_p)
qqnorm(custom_elevation$position_p, main="Custom elevation")
qqline(custom_elevation$position_p)
par(mfrow=c(1,1))
#From the output it can be deduced for position_p given raw, custom and custom_elevation
#- from the qqplot, it can be seen that the distribution in not normal due to the tails (both) which do not follow the straight line and also the main part of the distribution doesn't follow the straight line

#Then, a test for equality of variances is performed. This test can be used even if the two variables are not normal as the sample size is sufficiently large.
#test between raw and custom
var.test(raw$position_p, custom$position_p, conf.level = 0.99, alternative = c("two.sided"))
#test between custom and custom_elevation
var.test(custom$position_p, custom_elevation$position_p, conf.level = 0.99, alternative = c("two.sided"))
#From the output it can be deduced for position_p given raw and custom
#- from the test of equality of variances, with 99% confidence the two variances can be considered different and also the extremely low p-value (1.03e-6) reinforces the decision to decisively reject the hypothesis that the variances are equal
#also for position_p given custom and custom_elevation
#- from the test of equality of variances, with 99% confidence the two variances can be considered different and also the extremely low p-value (less than 2.2e-16) reinforces the decision to decisively reject the hypothesis that the variances are equal

#Therefore it is possible to carry out a test on the equality of the means by imposing the condition that the variance of the populations is unknown and different in the two populations.
#test between raw and custom
t.test(raw$position_p, custom$position_p, conf.level = 0.99, alternative = c("two.sided"), mu=0, var.equal = F)
#test between custom and custom_elevation
t.test(custom$position_p, custom_elevation$position_p, conf.level = 0.99, alternative = c("two.sided"), mu=0, var.equal = F)
#From the output it can be deduced for position_p given raw and custom
#- from the test of equality of means, with 99% confidence the two means can be considered different and also the high p-value (0.98) reinforces the decision to decisively reject the hypothesis that the means are equal
#also for position_p given custom and custom_elevation
#- from the test of equality of means, with 99% confidence the two means can be considered different and also the extremely low p-value (less than 2.2e-16) reinforces the decision to decisively reject the hypothesis that the means are equal

#so the custom road generator doesn't influence the average pitch, but the elevation influences the average pitch, the road generator influences the variance pitch.

#We proceed with the analysis of how road generator influences the z acceleration
#We study how acceleration_z varies with dataset
summary(raw$acceleration_z)
sd(raw$acceleration_z)
skewness(raw$acceleration_z)
kurtosis(raw$acceleration_z)
summary(custom$acceleration_z)
sd(custom$acceleration_z)
skewness(custom$acceleration_z)
kurtosis(custom$acceleration_z)
summary(custom_elevation$acceleration_z)
sd(custom_elevation$acceleration_z)
skewness(custom_elevation$acceleration_z)
kurtosis(custom_elevation$acceleration_z)
par(mfrow=c(1,3))
boxplot(raw$acceleration_z, main="Raw", horizontal=F)
boxplot(custom$acceleration_z, main="Custom", horizontal=F)
boxplot(custom_elevation$acceleration_z, main="Custom elevation", horizontal=F)
par(mfrow=c(1,1))
#From the output it can be deduced for acceleration_z given raw, custom and custom_elevation
#- from the summary there is very left asymmetry (median less than mean)
#- from boxplot, it confirms what said above because both the median is in the middle part of the box of 1st and 3rd quartile and the two minimum and maximum lines have different lengths (maximum longer than minimum) and there are outliers

#Then, a test is carried out on the difference in the means of two independent populations.
#First it is checked whether the two variables have a normal distribution through the qqplots.
par(mfrow=c(1,3))
qqnorm(raw$acceleration_z, main="Raw")
qqline(raw$acceleration_z)
qqnorm(custom$acceleration_z, main="Custom")
qqline(custom$acceleration_z)
qqnorm(custom_elevation$acceleration_z, main="Custom elevation")
qqline(custom_elevation$acceleration_z)
par(mfrow=c(1,1))
#From the output it can be deduced for acceleration_z given raw, custom and custom_elevation
#- from the qqplot, it can be seen that the distribution in not normal due to the tails (both) which do not follow the straight line and also the main part of the distribution doesn't follow the straight line

#Then, a test for equality of variances is performed. This test can be used even if the two variables are not normal as the sample size is sufficiently large.
#test between raw and custom
var.test(raw$acceleration_z, custom$acceleration_z, conf.level = 0.99, alternative = c("two.sided"))
#test between custom and custom_elevation
var.test(custom$acceleration_z, custom_elevation$acceleration_z, conf.level = 0.99, alternative = c("two.sided"))
#From the output it can be deduced for acceleration_z given raw and custom
#- from the test of equality of variances, with 99% confidence the two variances can be considered different and also the extremely low p-value (less than 2.2e-16) reinforces the decision to decisively reject the hypothesis that the variances are equal
#also for acceleration_z given custom and custom_elevation
#- from the test of equality of variances, with 99% confidence the two variances can be considered different and also the extremely low p-value (less than 2.2e-16) reinforces the decision to decisively reject the hypothesis that the variances are equal

#Therefore it is possible to carry out a test on the equality of the means by imposing the condition that the variance of the populations is unknown and different in the two populations.
#test between raw and custom
t.test(raw$acceleration_z, custom$acceleration_z, conf.level = 0.99, alternative = c("two.sided"), mu=0, var.equal = F)
#test between custom and custom_elevation
t.test(custom$acceleration_z, custom_elevation$acceleration_z, conf.level = 0.99, alternative = c("two.sided"), mu=0, var.equal = F)
#From the output it can be deduced for acceleration_z given raw and custom
#- from the test of equality of means, with 99% confidence the two means can be considered equal and also the low p-value (2.33e-4) reinforces the decision to decisively reject the hypothesis that the means are equal
#also for acceleration_z given custom and custom_elevation
#- from the test of equality of means, with 99% confidence the two means can be considered equal and also the extremely low p-value (less than 2.2e-16) reinforces the decision to decisively reject the hypothesis that the means are equal

#so the road generator influences the average z acceleration (also the variance).

```
